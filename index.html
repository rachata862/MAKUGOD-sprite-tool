<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sprite Tool V5 — Cut • Align • Preview • Trim • Pack • Export</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111824; --panel2:#0b1220; --bd:#233044;
      --text:#e6edf3; --muted:rgba(230,237,243,.75);
      --accent:#1f6feb; --accent2:#2d384a; --warn:#ffcc66; --bad:#ff5050;
      --r:16px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color-scheme: dark;
    }
    *{box-sizing:border-box}
    body{margin:0; background:var(--bg); color:var(--text);}

    header{padding:14px 16px; border-bottom:1px solid var(--bd);
      background:linear-gradient(180deg, rgba(17,24,36,.95), rgba(11,15,20,.92));
      position:sticky; top:0; z-index:10; backdrop-filter: blur(8px);
    }
    header .top{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    h1{margin:0; font-size:16px; letter-spacing:.2px;}
    .sub{font-size:12px; color:var(--muted)}

    .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px;
      border:1px solid var(--bd); border-radius:999px;
      background:rgba(11,18,32,.6); font-size:12px; color:var(--muted)
    }
    .pill.warn{border-color:rgba(255,204,102,.55); color:rgba(255,204,102,.95)}

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      padding:12px 16px 16px;
      align-items:stretch;
    }
    @media (max-width: 1100px){ .grid{grid-template-columns:1fr;} }

    .card{background:var(--panel); border:1px solid var(--bd); border-radius:var(--r);
      padding:12px; box-shadow: 0 10px 30px rgba(0,0,0,.25)
    }
    .card h2{margin:0 0 8px; font-size:13px; color:var(--muted); font-weight:650; letter-spacing:.2px}

    .hr{height:1px; background:var(--bd); margin:12px 0;}

    label{display:block; font-size:12px; color:var(--muted); margin:10px 0 6px;}
    input[type="number"], input[type="text"], select{
      width:100%; padding:10px 10px; border-radius:12px; border:1px solid var(--bd);
      background:var(--panel2); color:var(--text); outline:none;
    }
    input[type="number"]:focus, input[type="text"]:focus, select:focus{border-color:rgba(31,111,235,.85)}
    input[type="range"]{width:100%}

    .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 650px){ .row{grid-template-columns:1fr;} }

    .btnrow{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 650px){ .btnrow{grid-template-columns:1fr;} }

    button{
      width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--bd);
      background:var(--accent); color:white; cursor:pointer; font-weight:650;
    }
    button.secondary{background:var(--accent2)}
    button.ghost{background:transparent}
    button:disabled{opacity:.55; cursor:not-allowed}

    .hint{font-size:12px; color:var(--muted); line-height:1.4}
    .hint b{color:var(--text)}

    .toolbar{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .toolbar .group{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}

    .toggle{display:inline-flex; align-items:center; gap:8px; padding:8px 10px;
      border:1px solid var(--bd); border-radius:12px; background:rgba(11,18,32,.6);
      font-size:12px; color:var(--muted)
    }
    .toggle input{accent-color: var(--accent)}

    canvas{display:block; width:100%; background:var(--panel2); border:1px solid var(--bd); border-radius:var(--r);}

    .canvasWrap{position:relative;}
    .cornerTag{
      position:absolute; top:10px; right:10px;
      font-size:12px; color:var(--muted);
      padding:6px 10px; border-radius:999px; border:1px solid var(--bd);
      background:rgba(11,18,32,.75);
      pointer-events:none;
    }

    .filmstrip{display:flex; gap:8px; overflow:auto; padding:8px; border:1px solid var(--bd);
      border-radius:var(--r); background:rgba(11,18,32,.6)
    }
    .thumb{width:74px; min-width:74px; border:1px solid rgba(35,48,68,.9); border-radius:12px;
      background:rgba(0,0,0,.25); display:flex; flex-direction:column; gap:6px; padding:6px; cursor:pointer
    }
    .thumb.sel{outline:2px solid rgba(31,111,235,.95);}
    .thumb canvas{width:100%; height:auto; border:0; border-radius:10px; background:transparent}
    .thumb .t{font-size:11px; color:var(--muted); text-align:center}

    details{border:1px solid var(--bd); border-radius:14px; background:rgba(11,18,32,.35); padding:10px;}
    details + details{margin-top:10px;}
    summary{cursor:pointer; list-style:none; font-weight:700; color:var(--text);}
    summary::-webkit-details-marker{display:none;}
    summary .small{font-weight:600; color:var(--muted); font-size:12px; margin-left:8px;}

    .kbd{font-size:11px; padding:2px 6px; border:1px solid var(--bd); border-radius:8px;
      background:rgba(11,18,32,.6); color:var(--muted)
    }
    .warn{color:var(--warn)}
  </style>
</head>
<body>
<header>
  <div class="top">
    <div>
      <h1>Sprite Tool V5 — Cut • Align • Preview • Trim • Pack • Export</h1>
      <div class="sub">รวม setting เข้าแต่ละกล่อง • กรอบสีน้ำเงิน (Selected) ไม่หาย แม้เลื่อนออกนอกภาพ</div>
    </div>
    <div class="pill"><span id="imgInfo">No image</span> • <span id="frameInfo">0 frames</span></div>
  </div>
</header>

<div class="grid">
  <!-- Panel 1: Animation + controls -->
  <div class="card">
    <h2>1) Animation (ผลลัพธ์)</h2>

    <div class="toolbar">
      <div class="group">
        <button id="btnPlay" class="secondary" disabled>▶ Play / Pause</button>
        <button id="btnReset" class="ghost" disabled>Reset</button>
      </div>
      <div class="group">
        <span class="pill">FPS: <span id="fpsVal">8</span></span>
      </div>
    </div>

    <div class="row">
      <div>
        <label>FPS</label>
        <input id="fps" type="range" min="1" max="30" value="8" />
      </div>
      <div>
        <label>Frame index <span class="pill" id="idxVal">0</span></label>
        <input id="frameIdx" type="range" min="0" max="0" value="0" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>Loop</label>
        <select id="loopMode">
          <option value="loop">Loop</option>
          <option value="pingpong">Ping-pong</option>
          <option value="once">Once</option>
        </select>
      </div>
      <div>
        <label>Direction</label>
        <select id="dirMode">
          <option value="forward">Forward</option>
          <option value="reverse">Reverse</option>
        </select>
      </div>
    </div>

    <div class="canvasWrap" style="margin-top:10px;">
      <canvas id="anim" width="520" height="360"></canvas>
      <div class="cornerTag" id="animInfo">-</div>
    </div>

    <div class="hint" style="margin-top:10px;">
      <b>คีย์ลัด:</b> <span class="kbd">Space</span> play/pause • <span class="kbd">←</span>/<span class="kbd">→</span> เปลี่ยนเฟรม
    </div>
  </div>

  <!-- Panel 2: Image + cut/grid + zoom -->
  <div class="card">
    <h2>2) Image + Cut/Grid</h2>

    <div class="row">
      <div>
        <label>ใส่รูป (PNG แนะนำ)</label>
        <input id="file" type="file" accept="image/*" />
      </div>
      <div>
        <label>File name (สำหรับ export)</label>
        <input id="state" type="text" value="" placeholder="เช่น idle_walk / run_01 / sleep" />
      </div>
    </div>

    <div class="toolbar" style="margin-top:6px;">
      <div class="group">
        <label class="toggle"><input id="showGrid" type="checkbox" checked/> Grid</label>
        <label class="toggle"><input id="showPivot" type="checkbox" checked/> Pivot</label>
        <label class="toggle"><input id="pickMode" type="checkbox"/> Pick color</label>
      </div>
      <div class="group">
        <span class="pill">Zoom: <span id="zoomVal">1.00x</span></span>
        <input id="zoom" type="range" min="0.25" max="6" value="1" step="0.05" style="width:220px" />
        <select id="bg">
          <option value="checker">Checker</option>
          <option value="dark">Dark</option>
          <option value="light">Light</option>
        </select>
      </div>
    </div>

    <div class="canvasWrap" style="margin-top:10px;">
      <canvas id="cv" width="520" height="360"></canvas>
      <div class="cornerTag" id="imgCorner">No image</div>
    </div>

    <div id="warnBox" class="pill warn" style="margin-top:10px; display:none;">⚠ กรอบถูกเลื่อนออกนอกภาพ (ยังแสดงอยู่) — ปรับ Offset หรือ Zoom เพื่อเห็น</div>

    <details open style="margin-top:10px;">
      <summary>Cut / Grid <span class="small">อยู่กล่องเดียวกับภาพเพื่อปรับง่าย</span></summary>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>Cut mode</label>
          <select id="mode">
            <option value="colsrows">Columns + Rows</option>
            <option value="framesize">Frame Width + Height</option>
          </select>
        </div>
        <div>
          <label>Order</label>
          <select id="order">
            <option value="row">Row-major</option>
            <option value="col">Col-major</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Columns</label>
          <input id="cols" type="number" min="1" value="1" />
        </div>
        <div>
          <label>Rows</label>
          <input id="rows" type="number" min="1" value="1" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Frame Width (px)</label>
          <input id="fw" type="number" min="1" value="64" />
        </div>
        <div>
          <label>Frame Height (px)</label>
          <input id="fh" type="number" min="1" value="64" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Margin (px)</label>
          <input id="margin" type="number" min="0" value="0" />
        </div>
        <div>
          <label>Spacing (px)</label>
          <input id="spacing" type="number" min="0" value="0" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Frame Offset X (px)</label>
          <input id="offx" type="number" value="0" />
        </div>
        <div>
          <label>Frame Offset Y (px)</label>
          <input id="offy" type="number" value="0" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Frame Range</label>
          <select id="rangeMode">
            <option value="all">All</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="hint" style="padding-top:28px;">
          <span class="warn">ลากบนภาพ</span> เพื่อเลื่อนกรอบ (Offset) • กรอบ Selected จะไม่ถูกลบแล้ว
        </div>
      </div>

      <div id="rangeBox" class="row" style="display:none;">
        <div>
          <label>Start index</label>
          <input id="rangeStart" type="number" min="0" value="0" />
        </div>
        <div>
          <label>End index (inclusive)</label>
          <input id="rangeEnd" type="number" min="0" value="0" />
        </div>
      </div>

      <div class="hint" style="margin-top:10px;">
        <b>Total (หลัง apply range):</b> <span id="totalHint">0</span>
      </div>
    </details>
  </div>

  <!-- Panel 3: Frame picker + pivot/trim/export -->
  <div class="card">
    <h2>3) Frames + Pivot + Export</h2>

    <div class="row">
      <div>
        <label>Selected frame preview</label>
        <canvas id="prev" width="240" height="240"></canvas>
      </div>
      <div class="hint" style="padding-top:28px;">
        <div class="pill">Selected frame</div>
        <div id="prevInfo" style="margin-top:8px;">-</div>
        <div style="opacity:.85; margin-top:8px;">คลิก thumbnail เพื่อกำหนด pivot ตามจุดที่คลิก</div>
      </div>
    </div>

    <div class="hr"></div>

    <details open>
      <summary>Pivot / Trim / Color Key</summary>
      <div class="row" style="margin-top:10px;">
        <div>
          <label>Pivot X (0..1)</label>
          <input id="px" type="number" step="0.01" min="0" max="1" value="0.5" />
        </div>
        <div>
          <label>Pivot Y (0..1)</label>
          <input id="py" type="number" step="0.01" min="0" max="1" value="1.0" />
        </div>
      </div>

      <div class="btnrow">
        <button id="btnPivotBottom" class="secondary" disabled>Pivot = Bottom-Center</button>
        <button id="btnPivotCenter" class="secondary" disabled>Pivot = Center</button>
      </div>

      <label class="toggle" style="margin-top:10px;">
        <input id="trim" type="checkbox" />
        <span><b>Trim</b> โปร่งใสออก (ต่อเฟรม) + เก็บ offset/size ใน JSON</span>
      </label>

      <label class="toggle">
        <input id="colorkey" type="checkbox" />
        <span><b>Color key</b> ลบสีพื้นหลัง (ใช้ Pick color ที่กล่อง 2)</span>
      </label>

      <div class="row" style="align-items:center;">
        <div>
          <label>Key color</label>
          <input id="keyColor" type="text" value="#000000" />
        </div>
        <div>
          <label>Tolerance (0..255)</label>
          <input id="keyTol" type="number" min="0" max="255" value="20" />
        </div>
      </div>
    </details>

    <details>
      <summary>Pack / Export</summary>
      <div class="row" style="margin-top:10px;">
        <div>
          <label>Pack sprite sheet</label>
          <select id="packMode">
            <option value="none">No pack (source)</option>
            <option value="grid">Grid pack</option>
            <option value="shelf">Shelf pack</option>
          </select>
        </div>
        <div>
          <label>Padding (px)</label>
          <input id="pad" type="number" min="0" value="2" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Power-of-two (POT)</label>
          <select id="pot">
            <option value="no">No</option>
            <option value="yes">Yes</option>
          </select>
        </div>
        <div>
          <label>JSON format</label>
          <select id="jsonFmt">
            <option value="simple">Simple</option>
            <option value="tp">TexturePacker-ish</option>
          </select>
        </div>
      </div>

      <div class="btnrow">
        <button id="btnJSON" disabled>Export JSON</button>
        <button id="btnSheet" disabled>Download Sheet (PNG)</button>
      </div>
      <div class="btnrow">
        <button id="btnZIP" disabled>Download Frames (ZIP)</button>
        <button id="btnAll" class="secondary" disabled>Download ALL (ZIP)</button>
      </div>

      <div class="hint" style="margin-top:10px;">
        ถ้า ZIP ปิดอยู่ แปลว่า JSZip โหลดจาก CDN ไม่ได้ (องค์กรบล็อก/ออฟไลน์)
      </div>
    </details>

    <div class="hr"></div>

    <div class="hint" style="margin-bottom:8px;">Filmstrip</div>
    <div id="strip" class="filmstrip"></div>
  </div>
</div>

<script>
// ===== Boot helpers =====
const $=(id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const floorInt=(v,def=0)=>{const n=Math.floor(Number(v)); return Number.isFinite(n)?n:def;};
const nextPow2=(n)=>{let p=1; while(p<n) p<<=1; return p;};
const hexToRgb=(hex)=>{const m=String(hex).trim().match(/^#?([0-9a-f]{6})$/i); if(!m) return {r:0,g:0,b:0}; const x=parseInt(m[1],16); return {r:(x>>16)&255, g:(x>>8)&255, b:x&255};};

// ===== Elements =====
const el={
  anim: $('anim'), animInfo: $('animInfo'),
  cv: $('cv'), imgCorner: $('imgCorner'),
  prev: $('prev'), prevInfo: $('prevInfo'), strip: $('strip'),

  imgInfo: $('imgInfo'), frameInfo: $('frameInfo'), totalHint: $('totalHint'),

  file: $('file'), state: $('state'),

  mode: $('mode'), cols: $('cols'), rows: $('rows'), fw: $('fw'), fh: $('fh'),
  margin: $('margin'), spacing: $('spacing'), offx: $('offx'), offy: $('offy'), order: $('order'),
  rangeMode: $('rangeMode'), rangeStart: $('rangeStart'), rangeEnd: $('rangeEnd'), rangeBox: $('rangeBox'),

  px: $('px'), py: $('py'), btnPivotBottom: $('btnPivotBottom'), btnPivotCenter: $('btnPivotCenter'),
  trim: $('trim'), colorkey: $('colorkey'), keyColor: $('keyColor'), keyTol: $('keyTol'),

  fps: $('fps'), fpsVal: $('fpsVal'), frameIdx: $('frameIdx'), idxVal: $('idxVal'),
  loopMode: $('loopMode'), dirMode: $('dirMode'),

  showGrid: $('showGrid'), showPivot: $('showPivot'), pickMode: $('pickMode'),
  zoom: $('zoom'), zoomVal: $('zoomVal'), bg: $('bg'),

  packMode: $('packMode'), pad: $('pad'), pot: $('pot'), jsonFmt: $('jsonFmt'),

  btnPlay: $('btnPlay'), btnReset: $('btnReset'),
  btnJSON: $('btnJSON'), btnZIP: $('btnZIP'), btnSheet: $('btnSheet'), btnAll: $('btnAll'),

  warnBox: $('warnBox'),
};

const ctx=el.cv.getContext('2d');
const actx=el.anim.getContext('2d');
const pctx=el.prev.getContext('2d');
ctx.imageSmoothingEnabled=false;
actx.imageSmoothingEnabled=false;
pctx.imageSmoothingEnabled=false;

// ===== JSZip loader =====
let jszipReady=false;
(function(){
  const s=document.createElement('script');
  s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
  s.async=true;
  s.onload=()=>{jszipReady=true; syncZipButtons();};
  s.onerror=()=>{jszipReady=false; console.warn('JSZip failed to load. ZIP export disabled.'); syncZipButtons();};
  document.head.appendChild(s);
})();

// ===== State =====
let img=null;
let srcCanvas=null, srcCtx=null;
let frames=[];
let viewFrames=[];
let selected=0;
let playing=false;
let timer=null;
let pingDir=1;

function syncZipButtons(){
  if(!img){ el.btnZIP.disabled=true; el.btnAll.disabled=true; return; }
  el.btnZIP.disabled=!jszipReady;
  el.btnAll.disabled=!jszipReady;
}

function enableUI(on){
  el.btnPlay.disabled=!on;
  el.btnReset.disabled=!on;
  el.btnJSON.disabled=!on;
  el.btnSheet.disabled=!on;
  el.btnPivotBottom.disabled=!on;
  el.btnPivotCenter.disabled=!on;
  syncZipButtons();
}

async function loadImage(file){
  const url=URL.createObjectURL(file);
  const i=new Image();
  await new Promise((res,rej)=>{i.onload=res; i.onerror=rej; i.src=url;});
  URL.revokeObjectURL(url);
  return i;
}

function buildSrcCanvas(){
  srcCanvas=document.createElement('canvas');
  srcCanvas.width=img.width;
  srcCanvas.height=img.height;
  srcCtx=srcCanvas.getContext('2d');
  srcCtx.imageSmoothingEnabled=false;
  srcCtx.clearRect(0,0,img.width,img.height);
  srcCtx.drawImage(img,0,0);
}

function applyColorKeyIfNeeded(){
  if(!el.colorkey.checked) return;
  const {r:kr,g:kg,b:kb}=hexToRgb(el.keyColor.value);
  const tol=clamp(floorInt(el.keyTol.value,20),0,255);
  const im=srcCtx.getImageData(0,0,srcCanvas.width,srcCanvas.height);
  const d=im.data;
  for(let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    if(Math.abs(r-kr)<=tol && Math.abs(g-kg)<=tol && Math.abs(b-kb)<=tol) d[i+3]=0;
  }
  srcCtx.putImageData(im,0,0);
}

function paintChecker(g, W, H){
  const s=24;
  g.fillStyle='#0b1220';
  g.fillRect(0,0,W,H);
  for(let y=0;y<H;y+=s){
    for(let x=0;x<W;x+=s){
      const even=((x/s)+(y/s))%2===0;
      g.fillStyle=even?'rgba(255,255,255,.06)':'rgba(0,0,0,.10)';
      g.fillRect(x,y,s,s);
    }
  }
}

function bgPaint(g, W, H){
  if(el.bg.value==='checker') paintChecker(g, W, H);
  else if(el.bg.value==='light'){ g.fillStyle='#e9eef6'; g.fillRect(0,0,W,H); }
  else { g.fillStyle='#0b1220'; g.fillRect(0,0,W,H); }
}

function updateDerivedFields(){
  if(!img) return;
  const margin=clamp(floorInt(el.margin.value,0),0,99999);
  const spacing=clamp(floorInt(el.spacing.value,0),0,99999);

  if(el.mode.value==='framesize'){
    const offx=clamp(floorInt(el.offx.value,0),-999999,999999);
    const offy=clamp(floorInt(el.offy.value,0),-999999,999999);
    const startX=margin+offx;
    const startY=margin+offy;
    const fw=clamp(floorInt(el.fw.value,Math.max(1,img.width)),1,img.width*10);
    const fh=clamp(floorInt(el.fh.value,Math.max(1,img.height)),1,img.height*10);
    const availW = img.width - startX - margin;
    const availH = img.height - startY - margin;
    // IMPORTANT: keep at least 1×1 so frames never becomes empty
    const cols=Math.max(1, Math.floor((availW+spacing)/(fw+spacing)));
    const rows=Math.max(1, Math.floor((availH+spacing)/(fh+spacing)));
    el.cols.value=String(cols);
    el.rows.value=String(rows);
  } else {
    const cols=clamp(floorInt(el.cols.value,1),1,99999);
    const rows=clamp(floorInt(el.rows.value,1),1,99999);
    const fw=Math.floor((img.width-2*margin-(cols-1)*spacing)/cols);
    const fh=Math.floor((img.height-2*margin-(rows-1)*spacing)/rows);
    if(fw>0) el.fw.value=String(fw);
    if(fh>0) el.fh.value=String(fh);
  }
}

function computeTrimForFrame(fr){
  const sx=clamp(fr.x,0,img.width-1);
  const sy=clamp(fr.y,0,img.height-1);
  const sw=clamp(fr.w,1,img.width-sx);
  const sh=clamp(fr.h,1,img.height-sy);
  const im=srcCtx.getImageData(sx, sy, sw, sh);
  const d=im.data;
  let minX=sw, minY=sh, maxX=-1, maxY=-1;
  for(let y=0;y<sh;y++){
    for(let x=0;x<sw;x++){
      const a=d[(y*sw+x)*4+3];
      if(a!==0){
        if(x<minX) minX=x;
        if(y<minY) minY=y;
        if(x>maxX) maxX=x;
        if(y>maxY) maxY=y;
      }
    }
  }
  if(maxX<minX||maxY<minY) return {x:0,y:0,w:1,h:1,offX:0,offY:0,srcW:fr.w,srcH:fr.h,empty:true};
  const w=maxX-minX+1, h=maxY-minY+1;
  return {x:minX,y:minY,w,h,offX:minX,offY:minY,srcW:fr.w,srcH:fr.h,empty:false};
}

function fallbackFrame(){
  const margin=clamp(floorInt(el.margin.value,0),0,99999);
  const spacing=clamp(floorInt(el.spacing.value,0),0,99999);
  const offx=clamp(floorInt(el.offx.value,0),-999999,999999);
  const offy=clamp(floorInt(el.offy.value,0),-999999,999999);
  const startX=margin+offx;
  const startY=margin+offy;
  const w=clamp(floorInt(el.fw.value,Math.max(1,img.width)),1,img.width*10);
  const h=clamp(floorInt(el.fh.value,Math.max(1,img.height)),1,img.height*10);
  return {x:startX, y:startY, w, h};
}

function computeGridFrames(){
  const margin=clamp(floorInt(el.margin.value,0),0,99999);
  const spacing=clamp(floorInt(el.spacing.value,0),0,99999);
  const offx=clamp(floorInt(el.offx.value,0),-999999,999999);
  const offy=clamp(floorInt(el.offy.value,0),-999999,999999);
  const startX=margin+offx;
  const startY=margin+offy;

  const out=[];

  if(el.mode.value==='colsrows'){
    const cols=clamp(floorInt(el.cols.value,1),1,99999);
    const rows=clamp(floorInt(el.rows.value,1),1,99999);

    // IMPORTANT: keep at least 1px so selection never disappears
    const w=Math.max(1, Math.floor((img.width-2*margin-(cols-1)*spacing)/cols));
    const h=Math.max(1, Math.floor((img.height-2*margin-(rows-1)*spacing)/rows));

    const push=(r,c)=>out.push({x:startX+c*(w+spacing), y:startY+r*(h+spacing), w, h});
    if(el.order.value==='row'){
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) push(r,c);
    } else {
      for(let c=0;c<cols;c++) for(let r=0;r<rows;r++) push(r,c);
    }
    return out;
  }

  // framesize
  const fw=clamp(floorInt(el.fw.value,Math.max(1,img.width)),1,img.width*10);
  const fh=clamp(floorInt(el.fh.value,Math.max(1,img.height)),1,img.height*10);

  // IMPORTANT: do NOT drop frames when outside image; we still draw blue selection.
  const cols=Math.max(1, clamp(floorInt(el.cols.value,1),1,99999));
  const rows=Math.max(1, clamp(floorInt(el.rows.value,1),1,99999));

  const gen=(r,c)=>({x:startX+c*(fw+spacing), y:startY+r*(fh+spacing), w:fw, h:fh});
  if(el.order.value==='row'){
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) out.push(gen(r,c));
  } else {
    for(let c=0;c<cols;c++) for(let r=0;r<rows;r++) out.push(gen(r,c));
  }
  return out;
}

function applyRange(list){
  if(el.rangeMode.value!=='custom') return list;
  const s=clamp(floorInt(el.rangeStart.value,0),0,Math.max(0,list.length-1));
  const e=clamp(floorInt(el.rangeEnd.value,0),0,Math.max(0,list.length-1));
  const a=Math.min(s,e), b=Math.max(s,e);
  return list.slice(a,b+1);
}

function getFilePrefix(){
  const raw=(el.state.value||'').trim();
  return raw.length?raw:'sprite';
}

function drawImageCanvas(){
  const W=el.cv.width, H=el.cv.height;
  bgPaint(ctx, W, H);

  if(!img){
    ctx.fillStyle='#e6edf3';
    ctx.font='16px system-ui';
    ctx.fillText('อัปโหลดรูปเพื่อเริ่ม', 20, 40);
    el.imgCorner.textContent='No image';
    el.warnBox.style.display='none';
    return;
  }

  const z=Number(el.zoom.value);
  el.zoomVal.textContent=`${z.toFixed(2)}x`;

  const iw=img.width*z, ih=img.height*z;
  const ox=(W-iw)/2;
  const oy=(H-ih)/2;

  ctx.imageSmoothingEnabled=false;
  ctx.drawImage(srcCanvas, ox, oy, iw, ih);

  // Grid overlay
  if(el.showGrid.checked){
    ctx.strokeStyle='rgba(180,200,255,.22)';
    ctx.lineWidth=1;
    for(const fr of viewFrames){
      ctx.strokeRect(ox+fr.x*z, oy+fr.y*z, fr.w*z, fr.h*z);
    }
  }

  // Selected (always draw; if viewFrames missing use fallback)
  const fr=viewFrames[selected] || fallbackFrame();

  // warn if selected is fully outside view
  const sx=ox+fr.x*z, sy=oy+fr.y*z, sw=fr.w*z, sh=fr.h*z;
  const fullyOutside = (sx+sw<0) || (sy+sh<0) || (sx>W) || (sy>H);
  el.warnBox.style.display = fullyOutside ? 'inline-flex' : 'none';

  ctx.strokeStyle='rgba(31,111,235,.95)';
  ctx.lineWidth=2;
  ctx.strokeRect(sx, sy, sw, sh);

  if(el.trim.checked && viewFrames[selected] && viewFrames[selected].trim && !viewFrames[selected].trim.empty){
    const t=viewFrames[selected].trim;
    ctx.strokeStyle='rgba(255,255,255,.65)';
    ctx.lineWidth=1.5;
    ctx.strokeRect(ox+(viewFrames[selected].x+t.x)*z, oy+(viewFrames[selected].y+t.y)*z, t.w*z, t.h*z);
  }

  if(el.showPivot.checked){
    const px=Number(el.px.value), py=Number(el.py.value);
    const pivotX=fr.x + fr.w*(Number.isFinite(px)?px:0.5);
    const pivotY=fr.y + fr.h*(Number.isFinite(py)?py:1.0);
    ctx.fillStyle='rgba(255,80,80,.95)';
    ctx.beginPath();
    ctx.arc(ox+pivotX*z, oy+pivotY*z, 5, 0, Math.PI*2);
    ctx.fill();
  }

  el.imgCorner.textContent=`${img.width}×${img.height}px`;
}

function drawSelectedPreview(){
  paintChecker(pctx, el.prev.width, el.prev.height);
  if(!img || !viewFrames[selected]){
    el.prevInfo.textContent='-';
    return;
  }
  const fr=viewFrames[selected];
  const src = (el.trim.checked && fr.trim) ? fr.trim : {x:0,y:0,w:fr.w,h:fr.h,offX:0,offY:0,srcW:fr.w,srcH:fr.h,empty:false};
  const pad=14;
  const W=el.prev.width, H=el.prev.height;
  const scale=Math.min((W-2*pad)/src.w, (H-2*pad)/src.h);
  const dw=Math.max(1, Math.floor(src.w*scale));
  const dh=Math.max(1, Math.floor(src.h*scale));
  const dx=Math.floor((W-dw)/2);
  const dy=Math.floor((H-dh)/2);
  pctx.imageSmoothingEnabled=false;
  pctx.drawImage(srcCanvas, fr.x+src.x, fr.y+src.y, src.w, src.h, dx, dy, dw, dh);

  el.prevInfo.innerHTML = `Frame <b>${selected}</b><br/>Rect: ${fr.w}×${fr.h}` + (el.trim.checked?`<br/>Trim: ${src.w}×${src.h}`:'') + `<br/>Offset: (${floorInt(el.offx.value,0)}, ${floorInt(el.offy.value,0)})`;
}

function drawAnimationCanvas(){
  const W=el.anim.width, H=el.anim.height;
  paintChecker(actx, W, H);

  if(!img || viewFrames.length===0){
    el.animInfo.textContent='-';
    return;
  }

  const fr=viewFrames[selected];
  const src = (el.trim.checked && fr.trim) ? fr.trim : {x:0,y:0,w:fr.w,h:fr.h};
  const pad=18;
  const scale=Math.min((W-2*pad)/src.w, (H-2*pad)/src.h);
  const dw=Math.max(1, Math.floor(src.w*scale));
  const dh=Math.max(1, Math.floor(src.h*scale));
  const dx=Math.floor((W-dw)/2);
  const dy=Math.floor((H-dh)/2);

  actx.imageSmoothingEnabled=false;
  actx.drawImage(srcCanvas, fr.x+src.x, fr.y+src.y, src.w, src.h, dx, dy, dw, dh);

  el.animInfo.textContent = `Frame ${selected}/${Math.max(0,viewFrames.length-1)} • ${playing?'Playing':'Paused'}`;
}

function drawAll(){
  drawImageCanvas();
  drawSelectedPreview();
  drawAnimationCanvas();
}

function buildFilmstrip(){
  el.strip.innerHTML='';
  if(!img || viewFrames.length===0) return;

  for(let i=0;i<viewFrames.length;i++){
    const fr=viewFrames[i];
    const div=document.createElement('div');
    div.className='thumb'+(i===selected?' sel':'');

    const c=document.createElement('canvas');
    const max=64;
    const src=(el.trim.checked && fr.trim) ? fr.trim : {x:0,y:0,w:fr.w,h:fr.h};
    const s=Math.min(max/src.w, max/src.h);
    c.width=Math.max(1,Math.floor(src.w*s));
    c.height=Math.max(1,Math.floor(src.h*s));
    const cc=c.getContext('2d');
    cc.imageSmoothingEnabled=false;

    // clamp for safety
    const sx=clamp(fr.x+src.x,0,img.width-1);
    const sy=clamp(fr.y+src.y,0,img.height-1);
    const sw=clamp(src.w,1,img.width-sx);
    const sh=clamp(src.h,1,img.height-sy);
    cc.drawImage(srcCanvas, sx, sy, sw, sh, 0,0,c.width,c.height);

    const t=document.createElement('div');
    t.className='t';
    t.textContent=String(i);

    div.appendChild(c);
    div.appendChild(t);

    div.addEventListener('click', ()=>{
      selected=i;
      el.frameIdx.value=String(i);
      el.idxVal.textContent=String(i);
      buildFilmstrip();
      drawAll();
    });

    c.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      const rect=c.getBoundingClientRect();
      const mx=(ev.clientX-rect.left)/rect.width;
      const my=(ev.clientY-rect.top)/rect.height;
      let px=mx, py=my;
      if(el.trim.checked && fr.trim){
        const fx=fr.trim.x + mx*fr.trim.w;
        const fy=fr.trim.y + my*fr.trim.h;
        px=fx/fr.w;
        py=fy/fr.h;
      }
      el.px.value=String(clamp(px,0,1).toFixed(2));
      el.py.value=String(clamp(py,0,1).toFixed(2));
      drawAll();
    });

    el.strip.appendChild(div);
  }
}

function recompute(){
  if(!img){ drawAll(); return; }

  buildSrcCanvas();
  applyColorKeyIfNeeded();

  updateDerivedFields();

  frames=computeGridFrames();
  if(frames.length===0){
    // absolute fallback - never allow empty
    frames=[fallbackFrame()];
  }

  if(el.trim.checked){
    for(const fr of frames) fr.trim=computeTrimForFrame(fr);
  }else{
    for(const fr of frames) delete fr.trim;
  }

  viewFrames=applyRange(frames);
  if(viewFrames.length===0){
    viewFrames=[fallbackFrame()];
  }

  el.frameIdx.max=String(Math.max(0, viewFrames.length-1));
  selected=clamp(floorInt(el.frameIdx.value,0),0,Math.max(0, viewFrames.length-1));
  el.frameIdx.value=String(selected);
  el.idxVal.textContent=String(selected);

  el.rangeStart.max=String(Math.max(0, frames.length-1));
  el.rangeEnd.max=String(Math.max(0, frames.length-1));

  el.imgInfo.textContent=`${img.width}×${img.height}px`;
  el.frameInfo.textContent=`${viewFrames.length} frames`;
  el.totalHint.textContent=String(viewFrames.length);

  buildFilmstrip();
  enableUI(true);
  drawAll();
}

function stopTimer(){ if(timer) clearInterval(timer); timer=null; }
function startTimer(){
  stopTimer();
  const fps=clamp(floorInt(el.fps.value,8),1,60);
  const ms=Math.floor(1000/fps);
  const max=Math.max(0, viewFrames.length-1);
  const dir=(el.dirMode.value==='reverse')?-1:1;
  pingDir=dir;

  timer=setInterval(()=>{
    if(max<=0){ drawAnimationCanvas(); return; }
    if(el.loopMode.value==='pingpong'){
      selected += pingDir;
      if(selected>=max){ selected=max; pingDir=-1; }
      if(selected<=0){ selected=0; pingDir=1; }
    } else {
      selected += dir;
      if(selected>max){ if(el.loopMode.value==='once'){ selected=max; playing=false; stopTimer(); } else selected=0; }
      if(selected<0){ if(el.loopMode.value==='once'){ selected=0; playing=false; stopTimer(); } else selected=max; }
    }
    el.frameIdx.value=String(selected);
    el.idxVal.textContent=String(selected);
    buildFilmstrip();
    drawAnimationCanvas();
  }, ms);
}

function togglePlay(){
  if(!img) return;
  playing=!playing;
  el.btnPlay.textContent=playing?'⏸ Pause':'▶ Play / Pause';
  if(playing) startTimer(); else stopTimer();
  drawAnimationCanvas();
}

function resetAll(){
  playing=false; stopTimer();
  selected=0;
  el.frameIdx.value='0'; el.idxVal.textContent='0';
  el.fps.value='8'; el.fpsVal.textContent='8';
  el.loopMode.value='loop';
  el.dirMode.value='forward';
  el.showGrid.checked=true;
  el.showPivot.checked=true;
  el.pickMode.checked=false;
  el.bg.value='checker';
  el.zoom.value='1'; el.zoomVal.textContent='1.00x';
  el.offx.value='0';
  el.offy.value='0';
  recompute();
}

// ===== Interaction: drag offset / pick color =====
function canvasClientToCanvas(ev, canvas){
  const rect=canvas.getBoundingClientRect();
  const x=(ev.clientX-rect.left) * (canvas.width/rect.width);
  const y=(ev.clientY-rect.top) * (canvas.height/rect.height);
  return {x,y};
}

function pickColorAtCanvas(x,y){
  if(!img) return;
  const z=Number(el.zoom.value);
  const iw=img.width*z, ih=img.height*z;
  const ox=(el.cv.width-iw)/2;
  const oy=(el.cv.height-ih)/2;
  const sx=Math.floor((x-ox)/z);
  const sy=Math.floor((y-oy)/z);
  if(sx<0||sy<0||sx>=img.width||sy>=img.height) return;
  const p=srcCtx.getImageData(sx,sy,1,1).data;
  const hex='#'+[p[0],p[1],p[2]].map(v=>v.toString(16).padStart(2,'0')).join('');
  el.keyColor.value=hex;
}

let dragging=false;
let dragStart=null;
let dragStartOff=null;
let dragRAF=0;

el.cv.addEventListener('mousedown', (ev)=>{
  if(!img) return;
  if(el.pickMode.checked) return;
  dragging=true;
  dragStart=canvasClientToCanvas(ev, el.cv);
  dragStartOff={x: floorInt(el.offx.value,0), y: floorInt(el.offy.value,0)};
});

window.addEventListener('mouseup', ()=>{ dragging=false; dragStart=null; dragStartOff=null; });

window.addEventListener('mousemove', (ev)=>{
  if(!dragging || !img || !dragStart) return;
  if(dragRAF) return;
  dragRAF=requestAnimationFrame(()=>{
    dragRAF=0;
    const p=canvasClientToCanvas(ev, el.cv);
    const z=Number(el.zoom.value);
    const dx=(p.x-dragStart.x)/z;
    const dy=(p.y-dragStart.y)/z;
    el.offx.value=String(Math.round(dragStartOff.x + dx));
    el.offy.value=String(Math.round(dragStartOff.y + dy));
    recompute();
  });
});

el.cv.addEventListener('click', (ev)=>{
  if(!img) return;
  if(!el.pickMode.checked) return;
  const p=canvasClientToCanvas(ev, el.cv);
  pickColorAtCanvas(p.x,p.y);
  el.colorkey.checked=true;
  recompute();
});

// ===== Export =====
function downloadBlob(blob, filename){
  const a=document.createElement('a');
  const url=URL.createObjectURL(blob);
  a.href=url; a.download=filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 1500);
}

function getDurationMs(){
  const fps=clamp(floorInt(el.fps.value,8),1,60);
  return Math.floor(1000/fps);
}

function packGrid(sizes, pad){
  const n=sizes.length; if(n===0) return {width:1,height:1,placements:[]};
  const maxW=Math.max(...sizes.map(f=>f.w));
  const maxH=Math.max(...sizes.map(f=>f.h));
  const cols=Math.ceil(Math.sqrt(n));
  const rows=Math.ceil(n/cols);
  const width=cols*maxW + (cols+1)*pad;
  const height=rows*maxH + (rows+1)*pad;
  const placements=[];
  for(let i=0;i<n;i++){
    const c=i%cols, r=Math.floor(i/cols);
    placements.push({x:pad+c*(maxW+pad), y:pad+r*(maxH+pad), w:sizes[i].w, h:sizes[i].h});
  }
  return {width,height,placements};
}

function packShelf(sizes, pad){
  if(sizes.length===0) return {width:1,height:1,placements:[]};
  const area=sizes.reduce((s,f)=>s+(f.w+pad)*(f.h+pad),0);
  const targetW=Math.ceil(Math.sqrt(area));
  let x=pad,y=pad,shelfH=0,usedW=pad;
  const placements=[];
  for(const f of sizes){
    if(x+f.w+pad>targetW && x>pad){
      y+=shelfH+pad;
      x=pad;
      shelfH=0;
    }
    placements.push({x,y,w:f.w,h:f.h});
    x+=f.w+pad;
    shelfH=Math.max(shelfH,f.h);
    usedW=Math.max(usedW,x);
  }
  return {width:usedW+pad, height:y+shelfH+pad, placements};
}

function buildPackedSheet(){
  const pad=clamp(floorInt(el.pad.value,2),0,999);
  const active=viewFrames;

  if(el.packMode.value==='none'){
    const placements=active.map(fr=>({x:fr.x,y:fr.y,w:fr.w,h:fr.h}));
    return {mode:'none', canvas:srcCanvas, width:img.width, height:img.height, placements};
  }

  const sizes=active.map(fr=>{
    if(el.trim.checked && fr.trim) return {w:fr.trim.w,h:fr.trim.h};
    return {w:fr.w,h:fr.h};
  });

  const pack = (el.packMode.value==='grid') ? packGrid(sizes, pad) : packShelf(sizes, pad);
  let W=pack.width, H=pack.height;
  if(el.pot.value==='yes'){ W=nextPow2(W); H=nextPow2(H); }

  const out=document.createElement('canvas');
  out.width=W; out.height=H;
  const octx=out.getContext('2d');
  octx.imageSmoothingEnabled=false;
  octx.clearRect(0,0,W,H);

  const placements=[];
  for(let i=0;i<active.length;i++){
    const fr=active[i];
    const p=pack.placements[i];
    if(!p) continue;
    // clamp source for safety when frames are outside image
    const t=(el.trim.checked && fr.trim) ? fr.trim : null;
    const sx=fr.x+(t?t.x:0);
    const sy=fr.y+(t?t.y:0);
    const sw=(t?t.w:fr.w);
    const sh=(t?t.h:fr.h);
    const csx=clamp(sx,0,img.width-1);
    const csy=clamp(sy,0,img.height-1);
    const csw=clamp(sw,1,img.width-csx);
    const csh=clamp(sh,1,img.height-csy);
    octx.drawImage(srcCanvas, csx,csy,csw,csh, p.x, p.y, csw, csh);
    placements.push({x:p.x,y:p.y,w:csw,h:csh});
  }

  return {mode:el.packMode.value, canvas:out, width:W, height:H, placements};
}

async function canvasToPngBlob(c){
  return await new Promise(res=>c.toBlob(res,'image/png'));
}

function makeSimpleJSON(sheetName, packed, packedFrames){
  const duration=getDurationMs();
  const px=Number(el.px.value), py=Number(el.py.value);
  return {
    file: getFilePrefix(),
    sheet: sheetName,
    image: { width: packed.width, height: packed.height },
    source: { width: img.width, height: img.height },
    pivot: { x: Number.isFinite(px)?px:0.5, y: Number.isFinite(py)?py:1.0 },
    frames: viewFrames.map((src,i)=>{
      const pf=packedFrames[i];
      const t=(el.trim.checked && src.trim)?src.trim:null;
      return {
        index:i,
        frame:{x:pf.x,y:pf.y,w:pf.w,h:pf.h},
        duration_ms:duration,
        sourceRect:{x:src.x,y:src.y,w:src.w,h:src.h},
        ...(t?{trim:{x:t.x,y:t.y,w:t.w,h:t.h,offX:t.offX,offY:t.offY,srcW:t.srcW,srcH:t.srcH,empty:!!t.empty}}:{})
      };
    })
  };
}

function makeTexturePackerJSON(sheetName, packed, packedFrames){
  const prefix=getFilePrefix();
  const out={
    frames:{},
    meta:{app:'Sprite Tool V5', image:sheetName, size:{w:packed.width,h:packed.height}, scale:'1'}
  };
  for(let i=0;i<viewFrames.length;i++){
    const src=viewFrames[i];
    const pf=packedFrames[i];
    const key=`${prefix}_${String(i).padStart(3,'0')}.png`;
    const t=(el.trim.checked && src.trim)?src.trim:null;
    out.frames[key]={
      frame:{x:pf.x,y:pf.y,w:pf.w,h:pf.h}, rotated:false, trimmed:!!t,
      spriteSourceSize: t?{x:t.offX,y:t.offY,w:t.w,h:t.h}:{x:0,y:0,w:src.w,h:src.h},
      sourceSize:{w:src.w,h:src.h}
    };
  }
  return out;
}

async function exportJSON(){
  if(!img) return;
  const prefix=getFilePrefix();
  const packed=buildPackedSheet();
  const sheetName = (packed.mode==='none') ? '(source image)' : `${prefix}_sheet.png`;
  const json = (el.jsonFmt.value==='tp') ? makeTexturePackerJSON(sheetName, packed, packed.placements) : makeSimpleJSON(sheetName, packed, packed.placements);
  downloadBlob(new Blob([JSON.stringify(json,null,2)],{type:'application/json'}), `${prefix}.json`);
}

async function exportPackedSheet(){
  if(!img) return;
  const prefix=getFilePrefix();
  const packed=buildPackedSheet();
  const blob=await canvasToPngBlob((packed.mode==='none')?srcCanvas:packed.canvas);
  downloadBlob(blob, (packed.mode==='none')?`${prefix}_source.png`:`${prefix}_sheet.png`);
}

async function exportFramesZip(){
  if(!img) return;
  if(!window.JSZip){ alert('JSZip ยังโหลดไม่เสร็จ หรือโดนบล็อก CDN'); return; }
  const prefix=getFilePrefix();
  const zip=new JSZip();

  const off=document.createElement('canvas');
  const octx=off.getContext('2d');
  octx.imageSmoothingEnabled=false;

  for(let i=0;i<viewFrames.length;i++){
    const fr=viewFrames[i];
    const t=(el.trim.checked && fr.trim)?fr.trim:null;
    const sx=fr.x+(t?t.x:0), sy=fr.y+(t?t.y:0);
    const sw=(t?t.w:fr.w), sh=(t?t.h:fr.h);
    const csx=clamp(sx,0,img.width-1);
    const csy=clamp(sy,0,img.height-1);
    const csw=clamp(sw,1,img.width-csx);
    const csh=clamp(sh,1,img.height-csy);
    off.width=csw; off.height=csh;
    octx.clearRect(0,0,csw,csh);
    octx.drawImage(srcCanvas, csx,csy,csw,csh, 0,0,csw,csh);
    const blob=await new Promise(res=>off.toBlob(res,'image/png'));
    zip.file(`${prefix}_${String(i).padStart(3,'0')}.png`, await blob.arrayBuffer());
  }

  downloadBlob(await zip.generateAsync({type:'blob'}), `${prefix}_frames.zip`);
}

async function exportAllZip(){
  if(!img) return;
  if(!window.JSZip){ alert('JSZip ยังโหลดไม่เสร็จ หรือโดนบล็อก CDN'); return; }
  const prefix=getFilePrefix();
  const zip=new JSZip();

  const packed=buildPackedSheet();
  const sheetName = (packed.mode==='none') ? '(source image)' : `${prefix}_sheet.png`;
  const json = (el.jsonFmt.value==='tp') ? makeTexturePackerJSON(sheetName, packed, packed.placements) : makeSimpleJSON(sheetName, packed, packed.placements);
  zip.file(`${prefix}.json`, JSON.stringify(json,null,2));

  const off=document.createElement('canvas');
  const octx=off.getContext('2d');
  octx.imageSmoothingEnabled=false;
  for(let i=0;i<viewFrames.length;i++){
    const fr=viewFrames[i];
    const t=(el.trim.checked && fr.trim)?fr.trim:null;
    const sx=fr.x+(t?t.x:0), sy=fr.y+(t?t.y:0);
    const sw=(t?t.w:fr.w), sh=(t?t.h:fr.h);
    const csx=clamp(sx,0,img.width-1);
    const csy=clamp(sy,0,img.height-1);
    const csw=clamp(sw,1,img.width-csx);
    const csh=clamp(sh,1,img.height-csy);
    off.width=csw; off.height=csh;
    octx.clearRect(0,0,csw,csh);
    octx.drawImage(srcCanvas, csx,csy,csw,csh, 0,0,csw,csh);
    const blob=await new Promise(res=>off.toBlob(res,'image/png'));
    zip.file(`frames/${prefix}_${String(i).padStart(3,'0')}.png`, await blob.arrayBuffer());
  }

  const sheetCanvas=(packed.mode==='none')?srcCanvas:packed.canvas;
  const sheetBlob=await canvasToPngBlob(sheetCanvas);
  zip.file((packed.mode==='none')?`${prefix}_source.png`:`${prefix}_sheet.png`, await sheetBlob.arrayBuffer());

  downloadBlob(await zip.generateAsync({type:'blob'}), `${prefix}_bundle.zip`);
}

// ===== UI events =====
function setRangeUI(){
  const isCustom = (el.rangeMode.value==='custom');
  el.rangeBox.style.display = isCustom ? 'grid' : 'none';

  // UX fix: when switching to Custom, default to full range
  if(img && frames && frames.length){
    const max = Math.max(0, frames.length - 1);
    el.rangeStart.max = String(max);
    el.rangeEnd.max = String(max);

    if(isCustom){
      const s = clamp(floorInt(el.rangeStart.value, 0), 0, max);
      const e = clamp(floorInt(el.rangeEnd.value, max), 0, max);
      el.rangeStart.value = String(s);
      el.rangeEnd.value = String(Math.max(s, e));
    }
  }

  recompute();
}

el.mode.addEventListener('change', recompute);
el.rangeMode.addEventListener('change', setRangeUI);

for(const e of [el.cols,el.rows,el.fw,el.fh,el.margin,el.spacing,el.offx,el.offy,el.order,el.trim,el.colorkey,el.keyColor,el.keyTol,el.rangeStart,el.rangeEnd,el.packMode,el.pad,el.pot,el.jsonFmt]){
  e.addEventListener('input', recompute);
  e.addEventListener('change', recompute);
}

el.fps.addEventListener('input', ()=>{ el.fpsVal.textContent=el.fps.value; if(playing) startTimer(); drawAnimationCanvas(); });
el.frameIdx.addEventListener('input', ()=>{ selected=clamp(floorInt(el.frameIdx.value,0),0,Math.max(0,viewFrames.length-1)); el.idxVal.textContent=String(selected); buildFilmstrip(); drawAll(); });
el.loopMode.addEventListener('change', ()=>{ if(playing) startTimer(); });
el.dirMode.addEventListener('change', ()=>{ if(playing) startTimer(); });

el.btnPlay.addEventListener('click', togglePlay);
el.btnReset.addEventListener('click', resetAll);

el.btnPivotBottom.addEventListener('click', ()=>{ el.px.value='0.50'; el.py.value='1.00'; drawAll(); });
el.btnPivotCenter.addEventListener('click', ()=>{ el.px.value='0.50'; el.py.value='0.50'; drawAll(); });
el.px.addEventListener('input', drawAll);
el.py.addEventListener('input', drawAll);

el.btnJSON.addEventListener('click', exportJSON);
el.btnZIP.addEventListener('click', exportFramesZip);
el.btnSheet.addEventListener('click', exportPackedSheet);
el.btnAll.addEventListener('click', exportAllZip);

el.zoom.addEventListener('input', drawImageCanvas);
el.bg.addEventListener('change', drawAll);
el.showGrid.addEventListener('change', drawImageCanvas);
el.showPivot.addEventListener('change', drawImageCanvas);

el.file.addEventListener('change', async ()=>{
  const f=el.file.files?.[0];
  if(!f) return;
  img=await loadImage(f);

  // Defaults: start from image size (1 frame covering whole image)
  el.mode.value='framesize';
  el.fw.value=String(img.width);
  el.fh.value=String(img.height);
  el.cols.value='1';
  el.rows.value='1';
  el.margin.value='0';
  el.spacing.value='0';
  el.offx.value='0';
  el.offy.value='0';
  el.order.value='row';
  el.rangeMode.value='all';

  playing=false; stopTimer();
  selected=0;
  el.frameIdx.value='0'; el.idxVal.textContent='0';

  enableUI(true);
  setRangeUI();
  recompute();
});

window.addEventListener('keydown', (e)=>{
  if(e.code==='Space'){ e.preventDefault(); if(!el.btnPlay.disabled) togglePlay(); }
  if(e.code==='ArrowRight'){ if(!img) return; selected=clamp(selected+1,0,Math.max(0,viewFrames.length-1)); el.frameIdx.value=String(selected); el.idxVal.textContent=String(selected); buildFilmstrip(); drawAll(); }
  if(e.code==='ArrowLeft'){ if(!img) return; selected=clamp(selected-1,0,Math.max(0,viewFrames.length-1)); el.frameIdx.value=String(selected); el.idxVal.textContent=String(selected); buildFilmstrip(); drawAll(); }
});

// ===== Initial render =====
enableUI(false);
el.fpsVal.textContent=el.fps.value;
paintChecker(ctx, el.cv.width, el.cv.height);
paintChecker(actx, el.anim.width, el.anim.height);
paintChecker(pctx, el.prev.width, el.prev.height);
</script>
</body>
</html>
